{"/_app":{"title":" App","data":{"":""}},"/docs/codec":{"title":"Proto Codec","data":{"":"Proto Codec - short of Protocol Buffer codec is basically a mapping for supported message types. It is used to decode protocol buffer messages. It is used alongside DirectSignDecoder.","protocodec#ProtoCodec":"","methods#Methods":"","registertype#registerType":"registerType(typeUrl: string, generatedType: GeneratedType): void\nRegisters a new message type to the codec. The typeUrl is the type url of the message and generatedType is a GeneratedType. It basically means, when a message with typeUrl is received, the codec will use the generatedType to decode the message.","unpackany#unpackAny":"unpackAny(any: Any): AnyWithUnpacked\nUnpacks an Any message. It will return an AnyWithUnpacked object which contains the unpacked message and the typeUrl of the message. You can access the unpacked message using message property and the factory via the related factory property.This method will return an UnknownMessage type if the message is not registered in the codec.","protofactory#ProtoFactory":"A ProtoFactory is an interface that is expected by the ProtoCodec in order to decode a message successfully.\ninterface ProtoFactory {\nencode: (message: any, writer?: Writer) => Writer\ndecode: (r: Reader | Uint8Array, l?: number) => any\nfromJSON: (object: any) => any\ntoJSON: (message: any) => any\n}","usage#Usage":"In order to register a new generated type in the default codec, you need to do the following -\nimport { defaultProtoCode } from '@leapwallet/buffer-boba';\nimport { sdkName } from 'some-library';\n\ndefaultProtoCodec.registerProtoFactory(sdkName.someMessage.typeUrl, sdkName.someMessage.generatedType);\nThe convertToProtoFactory function will convert the generated message to a ProtoFactory that is expected by the codec. Basically, it will add the fromJSON and toJSON methods to the object.Now this updated codec can be used in the DirectSignDecoder to decode the messages in the following manner -\n// signDoc is a SignDoc object\n// defaultProtoCodec is the updated defaultProtoCodec object\nconst decoder = new DirectSignDecoder(signDoc, defaultProtoCodec);\nYou can use this decoder for your custom use-cases.","unknownmessage#UnknownMessage":"The UnknownMessage class is one that implements the Any interface. It represents an unknown message type that cannot be deserialized into a known message type.","constructor#Constructor":"The UnknownMessage class has a constructor that takes two parameters:\n_typeUrl: a string representing the URL of the message type.\n_value: a Uint8Array representing the serialized message.","getters#Getters":"The UnknownMessage class has two getters:\ntypeUrl: a string representing the URL of the message type.\nvalue: a Uint8Array representing the serialized message.","methods-1#Methods":"","tojson#toJSON":"The UnknownMessage class has a toJSON method that returns a JSON representation of the message. It returns an object with two properties:\ntype_url: a string representing the URL of the message type.\nvalue: a base64-encoded string representing the serialized message."}},"/docs/converters":{"title":"Message Converters","data":{"":"","message-converters#Message Converters":"Message Converters are used to convert between Amino JSON objects and their corresponding Protobuf objects. The Amino converters are used by the Amino codec to encode and decode Amino JSON objects.","msgconverter#MsgConverter":"","convertfromaminotodirect#convertFromAminoToDirect":"const aminoMsg = {\ntype: 'cosmos-sdk/MsgSend',\nvalue: {\nfrom_address: 'cosmos1huydeevpz37sd9snkgul6070mstupukw00xkw9',\nto_address: 'cosmos1cxlt8kzn6amtdxsj4xu0kz47hcvsuf4rwpqj7c',\namount: [\n{\ndenom: 'uatom',\namount: '1000000'\n}\n]\n}\n}\n\nMsgConverter.convertFromAminoToDirect(aminoMsg.type, aminoMsg.value)","convertfromdirecttoamino#convertFromDirectToAmino":"const directMsg = {\n// ...\n}\n\nMsgConverter.convertFromDirectToAmino(directMsg['@typeUrl'], ...directMsg.value)"}},"/docs/decoder":{"title":"Decoder","data":{"":"The primary purpose of the library is to decode the SignDoc received from dApps. We provide a couple of ways to do so.","directsigndocdecoder#DirectSignDocDecoder":"This class is the simplest way to decode a SignDoc. You can use it in the following way:","get-json-data#get JSON data":"import { DirectSignDocDecoder } from \"@leapwallet/buffer-boba\";\n\n// signDoc is the SignDoc received from dApps\nconst signDoc = {}\n\n// decoder is the instance of DirectSignDocDecoder\nconst decoder = new DirectSignDocDecoder(signDoc);\n\n// decoded to-be txn data\nconst jsonPayload = decoder.toJSON();\nHere the argument is a SignDoc object defined inside cosmos.tx.v1beta1.SignDoc. It looks like this:\ninterface SignDoc {\n/**\n* body_bytes is protobuf serialization of a TxBody that matches the\n* representation in TxRaw.\n*/\nbodyBytes: Uint8Array;\n/**\n* auth_info_bytes is a protobuf serialization of an AuthInfo that matches the\n* representation in TxRaw.\n*/\nauthInfoBytes: Uint8Array;\n/**\n* chain_id is the unique identifier of the chain this transaction targets.\n* It prevents signed transactions from being used on another chain by an\n* attacker\n*/\nchainId: string;\n/** account_number is the account number of the account in state */\naccountNumber: Long;\n}\nWe have another method called decode on the DirectSignDocDecoder class which returns the decoded payload as a Uint8Array. You can use it in the following way:\nimport { DirectSignDocDecoder } from \"@leapwallet/buffer-boba\";\n\n// signDoc is the SignDoc received from dApps\nconst signDoc = new Uint8Array([/* ... */]);\n\n// decoder is the instance of DirectSignDocDecoder\nconst decoder = DirectSignDocDecoder.decodeBytes(signDoc);\n\n// decoded to-be txn data\nconst jsonPayload = decoder.toJSON();","methods#Methods":"","constructor#constructor":"constructor(signDoc: SignDoc, protoCodec?: ProtoCodec): DirectSignDocDecoder\nThe constructor takes in a SignDoc object and an optional ProtoCodec object. The ProtoCodec object is used to decode the messages in txBody. If not provided, it will use the defaultProtoCodec object.","tojson#toJSON":"toJSON(): { txBody: TxBody, authInfo: AuthInfo, chainId: string, accountNumber: string }\nThis method returns the decoded payload as an object.","decodebytes#decodeBytes":"static decodeBytes(signDoc: Uint8Array, protoCodec?: ProtoCodec): DirectSignDocDecoder\nThis method takes in a SignDoc object as a Uint8Array and an optional ProtoCodec object. The ProtoCodec object is used to decode the messages in txBody. If not provided, it will use the defaultProtoCodec object.","tobytes#toBytes":"toBytes(): Uint8Array\nThis method returns the SignDoc as a Uint8Array.","properties#Properties":"","txbody#txBody":"txBody: TxBody\nThis property returns the decoded TxBody object.\n/** TxBody is the body of a transaction that all signers sign over. */\ninterface TxBody {\n/**\n* messages is a list of messages to be executed. The required signers of\n* those messages define the number and order of elements in AuthInfo's\n* signer_infos and Tx's signatures. Each required signer address is added to\n* the list only the first time it occurs.\n* By convention, the first required signer (usually from the first message)\n* is referred to as the primary signer and pays the fee for the whole\n* transaction.\n*/\nmessages: Any[];\n/**\n* memo is any arbitrary note/comment to be added to the transaction.\n* WARNING: in clients, any publicly exposed text should not be called memo,\n* but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).\n*/\nmemo: string;\n/**\n* timeout is the block height after which this transaction will not\n* be processed by the chain\n*/\ntimeoutHeight: Long;\n/**\n* extension_options are arbitrary options that can be added by chains\n* when the default options are not sufficient. If any of these are present\n* and can't be handled, the transaction will be rejected\n*/\nextensionOptions: Any[];\n/**\n* extension_options are arbitrary options that can be added by chains\n* when the default options are not sufficient. If any of these are present\n* and can't be handled, they will be ignored\n*/\nnonCriticalExtensionOptions: Any[];\n}","txmsgs#txMsgs":"txMsgs: AnyWithUnpacked[]\nReturns the messages in the TxBody object.\ntype Any = {\ntypeUrl: string;\nvalue: Uint8Array;\n};\n\ntype AnyWithUnpacked = Any | (Any & { unpacked: unknown; toJSON: () => any });\nAny is a protocol buffer message defined here - https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/any.proto","authinfo#authInfo":"authInfo: AuthInfo\nThis property returns the decoded AuthInfo object.\n/**\n* AuthInfo describes the fee and signer modes that are used to sign a\n* transaction.\n*/\nexport interface AuthInfo {\n/**\n* signer_infos defines the signing modes for the required signers. The number\n* and order of elements must match the required signers from TxBody's\n* messages. The first element is the primary signer and the one which pays\n* the fee.\n*/\nsignerInfos: SignerInfo[];\n/**\n* Fee is the fee and gas limit for the transaction. The first signer is the\n* primary signer and the one which pays the fee. The fee can be calculated\n* based on the cost of evaluating the body and doing signature verification\n* of the signers. This can be estimated via simulation.\n*/\nfee?: Fee;\n}","chainid#chainId":"chainId: string\nThis property returns the chain ID.","accountnumber#accountNumber":"accountNumber: string\nThis property returns the account number."}},"/docs":{"title":"Getting Started","data":{"":"","motivation#Motivation":"At leapwallet, we believe that we should give cosmos users the best wallet experience. An integral part of the wallet is its transaction signing page as that is the way users interact with dApps on the chain. Users sign transactions on this page and we want the users to be able to see what they are signing off on. We want to show a transaction overview, descriptions of all the messages and the data in JSON format.To do this, we need the protocol buffer definitions of all the messages in the transaction. However, there is no standard way to get the protocol buffer definitions of the messages in a transaction. This is where Buffer Boba comes in. It is a javascript library that allows you to decode the Protocol Buffer data in a standard way.This is a simple and easy to use library that allows you to decode the protocol buffer data in a transaction.","installation#Installation":"You can use your favourtie package manager to install the library\n\n\nyarn add @leapwallet/buffer-boba\n\n\n\nnpm install @leapwallet/buffer-boba\n\n\n\npnpm add @leapwallet/buffer-boba"}},"/":{"title":"Introducing Buffer Boba by LeapWallet.io","data":{"":""}}}